# STM32 PID Ball-on-Beam Balancer

This project is a single-axis ball balancing system built using an STM32F103C8T6 (Blue Pill) microcontroller. The system utilizes a **PID (Proportional-Integral-Derivative)** control algorithm to keep a ball balanced on a beam.

The ball's position is read by a **Sharp GP2Y0A60SZ0F** analog IR distance sensor, and the beam's tilt is controlled by an **MG996R** servo motor.

---

## ðŸ› ï¸ Hardware Used

* **Microcontroller:** STM32F103C8T6 ("Blue Pill")
* **Distance Sensor:** Sharp GP2Y0A60SZ0F (10-150cm, Analog)
* **Actuator:** MG996R High Torque Servo Motor
* **Development Rig:** Breadboard, custom-etched PCB, and jumper wires.

## ðŸ’» Software & Tools

* **IDE:** STM32CubeIDE
* **Configuration:** STM32CubeMX
* **Core Libraries:** STM32 HAL (Hardware Abstraction Layer)
* **Control Algorithm:** PID Control

---

## ðŸš€ Project Journey (Sensor Selection)

My initial choice for this project was the **VL53L0X Laser Time-of-Flight (ToF)** sensor, selected for its high precision. This sensor communicates over the I2C protocol.

However, during development, I encountered significant challenges integrating its library with the STM32 platform. Managing the I2C communication and library dependencies began to detract from the main focus of the project: the PID controller.

Therefore, I decided to pivot to a simpler, more direct approach: the **Sharp GP2Y0A60SZ0F** analog distance sensor. This sensor provides a direct analog voltage output corresponding to the distance. By using the STM32's built-in ADC (Analog-to-Digital Converter), I could easily read the data and dedicate my full attention to the mathematics of the PID algorithm.

---

## ðŸ§® Core Logic & Mathematical Calculations

The heart of the code is built on three main tasks: converting raw sensor data into a physical distance, maintaining that distance at a target (PID), and translating the PID output into a servo motor angle.

### 1. Sensor Data Linearization (`adc_to_cm`)

A key characteristic of Sharp IR sensors is that their output is **not linear** with distance. The output voltage is complex and inversely proportional to the distance (1/d). For the PID controller to function correctly, we must convert the raw ADC value into a linear distance in `cm`.

```c
float adc_to_cm(uint16_t adc)
{
    // 1. Convert ADC value (0-4095) to voltage (0-3.3V)
    float voltage = (adc * 3.3f) / 4096.0f;

    // 2. Power Regression
    float calculated_distance = 12.08f * powf(voltage, -1.058f);

    // ... (Filter out-of-range values)
    return calculated_distance;
}
````

  * **Why `powf(voltage, -1.058f)`?**
    This formula is the result of a **"Power Regression"** (curve fitting) applied to the graph in the sensor's datasheet (or from experimentally gathered data).
      * Formula: `Distance = A * (Voltage ^ B)`
      * Here, `A (12.08)` and `B (-1.058)` are the calibration coefficients that provide the most accurate results for my specific sensor and setup. This formula effectively linearizes the non-linear voltage into a linear distance in `cm`.

### 2\. The PID Control Algorithm (`pid_control`)

This function is the brain of the system. Its goal is to reduce the `error` (the difference between the `setpoint_val` and the `measured_value`) to zero.

```c
float pid_control(float setpoint_val, float measured_value)
{
    // P: Present Error
    error = setpoint_val - measured_value;

    // I: Accumulation of Past Errors
    integral += error;
    // ... (Integral Windup Protection) ...

    // D: Prediction of Future Error (Rate of Change)
    derivative = error - previous_error;
    previous_error = error;

    // PID Output
    float pid_out = (Kp * error) + (Ki * integral) + (Kd * derivative);
    
    // ... (Output Clamping) ...
    return pid_out;
}
```

  * **`Kp` (Proportional):** Determines how strongly to react to the *current* error. A high Kp means a fast response, but can lead to overshoot and oscillation.
  * **`Ki` (Integral):** Corrects for systematic, past errors. If the ball consistently stops 1cm away from the target, the integral term will slowly build up to correct this steady-state error.
      * **Integral Windup Protection:** The `if (integral > 100.0f)` checks are crucial. They prevent the integral term from "winding up" to an excessively large value (e.g., if the system is saturated or the servo is at its limit). This is critical for regaining control.
  * **`Kd` (Derivative):** Looks at how *fast* the error is changing. It "sees" the ball approaching the target quickly and applies a "brake" to prevent it from overshooting. This dampens oscillations.

### 3\. Servo Motor Control (`set_servo_angle`)

The "correction signal" (`pid_out`) generated by the algorithm must be converted into a physical servo angle. Servo motors are controlled by the *pulse width* of a 50Hz (20ms period) PWM signal.

```c
void set_servo_angle(float angle)
{
    // 1. Clamp the angle to avoid mechanical damage
    if (angle < 30.0f) angle = 30.0f;
    if (angle > 150.0f) angle = 150.0f;

    // 2. Map Angle (0-180) to Pulse Width (500-2500 microseconds)
    // (Typical range for MG996R is ~500us to 2500us)
    uint32_t pulse = 500 + (angle / 180.0f) * 2000.0f;

    // 3. Update the Timer's Compare Register
    __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, pulse);
}
```

  * **The Math:** In `main.c`, `TIM1` is configured with a `Prescaler` of 72-1 and a `Period` of 20000-1.
      * `Prescaler = 72-1`: Divides the 72MHz system clock by 72, resulting in a 1MHz timer frequency. This means each "tick" is 1 microsecond (1Âµs).
      * `Period = 20000-1`: The timer counts from 0 to 19999, giving a total period of 20,000 Âµs, which is 20 milliseconds (ms). This is the standard 50Hz frequency for servos.
  * **The Formula:** `pulse = 500 + (angle / 180.0f) * 2000.0f` linearly maps an angle from 0-180Â° to a pulse width between 500Âµs (for 0Â°) and 2500Âµs (for 180Â°).
  * **The PID Connection:** The line `float servo_angle = 90.0f + output;` in the main loop takes the PID output (e.g., -20) and applies it as a correction to the servo's neutral position (90Â°), resulting in a new target angle (e.g., 70Â°).

-----

## ðŸ“¡ Real-Time Tuning & Control

A powerful feature of this project is the ability to send commands over `USART1` (UART). By connecting any serial terminal (e.g., PuTTY, Arduino Serial Monitor) at **115200 baud**, you can send the following commands:

  * **Set PID Gains:**
      * `SET_PID:P2.8,I0.1,D0.4`
      * (Instantly updates Kp, Ki, and Kd values)
  * **Set Target Position (Setpoint):**
      * `SET_SETPOINT:15.0`
      * (Sets the target balance point to 15.0 cm)
  * **Start/Stop Control Loop:**
      * `START_CONTROL`
      * `STOP_CONTROL` (Stops the PID loop and centers the servo)

The system also continuously streams telemetry data, which can be visualized in a serial plotter:

  * **Output Format:** `POS:12.34,SET:13.00,SERVO:85.20`
      * `POS`: Current position of the ball (cm)
      * `SET`: Current setpoint (cm)
      * `SERVO`: Current servo angle (degrees)

<!-- end list -->

```
```
